---
import { readFile, readdir } from 'node:fs/promises';
import path from 'node:path';
import Layout from '../components/Layout.astro';

const samplesDir = new URL('../../../samples/', import.meta.url);
const sampleFiles = (await readdir(samplesDir, { withFileTypes: true }))
  .filter((entry) => entry.isFile())
  .map((entry) => entry.name)
  .sort((a, b) => a.localeCompare(b));

const samples = await Promise.all(
  sampleFiles.map(async (file) => {
    const content = await readFile(new URL(file, samplesDir), 'utf-8');
    return {
      name: file,
      slug: path.parse(file).name,
      content
    };
  })
);

const defaultSample = samples.find((sample) => sample.name === 'minimal.otab') ?? samples[0];
const samplesJson = JSON.stringify(samples);
---

<Layout title="Try It">
  <h1 class="page-title">Try OpenTab</h1>
  <p>Paste an <code>.otab</code> snippet to preview a quick summary and ASCII render.</p>

  <section class="try-grid">
    <div class="card">
      <h2>Input</h2>
      <label for="sample-select">Load a sample</label>
      <select id="sample-select">
        {samples.map((sample) => (
          <option value={sample.slug} selected={sample.slug === defaultSample.slug}>
            {sample.name}
          </option>
        ))}
      </select>
      <textarea id="otab-input" class="try-textarea" rows="18">{defaultSample?.content}</textarea>
    </div>
    <div class="card">
      <h2>Parsed summary</h2>
      <dl class="summary-list">
        <div>
          <dt>Tracks</dt>
          <dd id="summary-tracks">0</dd>
        </div>
        <div>
          <dt>Measures</dt>
          <dd id="summary-measures">0</dd>
        </div>
      </dl>
    </div>
  </section>

  <section class="section">
    <div class="card">
      <h2>ASCII tab</h2>
      <pre><code id="ascii-output"></code></pre>
    </div>
  </section>

  <section class="section">
    <div class="card">
      <h2>Validation errors</h2>
      <ul id="error-list" class="error-list"></ul>
      <p id="error-empty" class="error-empty">No validation issues found.</p>
    </div>
  </section>

  <script type="application/json" id="sample-data">{samplesJson}</script>
  <script type="module">
    const sampleData = document.getElementById('sample-data');
    const samples = JSON.parse(sampleData.textContent);
    const sampleSelect = document.getElementById('sample-select');

    const input = document.getElementById('otab-input');
    const summaryTracks = document.getElementById('summary-tracks');
    const summaryMeasures = document.getElementById('summary-measures');
    const asciiOutput = document.getElementById('ascii-output');
    const errorList = document.getElementById('error-list');
    const errorEmpty = document.getElementById('error-empty');

    const defaultTuning = ['E4', 'B3', 'G3', 'D3', 'A2', 'E2'];

    const parseTuning = (headerLines) => {
      const tuningLine = headerLines.find((line) => line.trim().startsWith('tuning'));
      if (!tuningLine) return null;
      const match = tuningLine.match(/\[(.*)\]/);
      if (!match) return null;
      return match[1]
        .split(',')
        .map((entry) => entry.trim().replace(/^"|"$/g, ''))
        .filter(Boolean);
    };

    const appendSlot = (lines, targetIndex, fret) => {
      const width = fret.length + 2;
      lines.forEach((_, index) => {
        const segment = index === targetIndex
          ? `-${fret}-`
          : '-'.repeat(width);
        lines[index] += segment;
      });
    };

    const renderAsciiTab = (bodyLines, tuning) => {
      const stringCount = tuning?.length ?? 6;
      const labels = [];
      for (let stringNumber = stringCount; stringNumber >= 1; stringNumber -= 1) {
        const label = tuning?.[stringNumber - 1] ?? `S${stringNumber}`;
        labels.push(label.padEnd(3, ' '));
      }

      const lines = labels.map((label) => `${label}|`);
      const matches = bodyLines.flatMap((line) => Array.from(line.matchAll(/\((\d+):(\d+)\)/g)));

      if (matches.length === 0) {
        return lines.map((line) => `${line}-`).join('\n');
      }

      matches.forEach((match) => {
        const stringNumber = Number(match[1]);
        const fret = match[2];
        const targetIndex = (stringCount - stringNumber);
        if (targetIndex < 0 || targetIndex >= lines.length) {
          appendSlot(lines, -1, fret);
          return;
        }
        appendSlot(lines, targetIndex, fret);
      });

      return lines.join('\n');
    };

    const parseOtab = (text) => {
      const lines = text.split(/\r?\n/);
      const dividerIndex = lines.findIndex((line) => line.trim() === '---');
      const headerLines = dividerIndex === -1 ? lines : lines.slice(0, dividerIndex);
      const bodyLines = dividerIndex === -1 ? [] : lines.slice(dividerIndex + 1);
      const headerText = headerLines.join('\n');
      const bodyText = bodyLines.join('\n');

      const errors = [];
      if (dividerIndex === -1) {
        errors.push('Missing "---" separator between header and body.');
      }

      const hasFormat = /format\s*=\s*"?opentab"?/i.test(headerText);
      const hasVersion = /version\s*=\s*"?0\.1"?/i.test(headerText);

      if (!hasFormat) errors.push('Missing required header field: format = "opentab".');
      if (!hasVersion) errors.push('Missing required header field: version = "0.1".');

      const trackCount = headerLines.filter((line) => line.trim() === '[[tracks]]').length;
      if (trackCount === 0) errors.push('No [[tracks]] entries found in header.');

      const measureMatches = bodyText.match(/m\d+:/g) ?? [];
      const fallbackMeasures = bodyLines.filter((line) => line.includes('|')).length;
      const measureCount = measureMatches.length || fallbackMeasures;
      if (dividerIndex !== -1 && bodyText.trim() && measureCount === 0) {
        errors.push('No measure lines detected in body.');
      }

      const tuning = parseTuning(headerLines);
      const ascii = renderAsciiTab(bodyLines, tuning ?? defaultTuning);

      return { trackCount, measureCount, ascii, errors };
    };

    const sampleMap = new Map(samples.map((sample) => [sample.slug, sample]));

    const loadSample = (slug) => {
      const sample = sampleMap.get(slug);
      if (!sample) return;
      input.value = sample.content;
      render();
    };

    const render = () => {
      const { trackCount, measureCount, ascii, errors } = parseOtab(input.value);
      summaryTracks.textContent = String(trackCount);
      summaryMeasures.textContent = String(measureCount);
      asciiOutput.textContent = ascii;

      errorList.innerHTML = '';
      errors.forEach((error) => {
        const item = document.createElement('li');
        item.textContent = error;
        errorList.appendChild(item);
      });
      errorEmpty.hidden = errors.length > 0;
    };

    sampleSelect.addEventListener('change', (event) => {
      loadSample(event.target.value);
    });
    input.addEventListener('input', render);
    render();
  </script>
</Layout>
